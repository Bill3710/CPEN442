import random
from typing import Callable
from Crypto.Util import number
from Crypto.Hash import SHA256
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from a3secret import mod_pow


def extended_gcd(a: int, b: int) -> tuple[int, int, int]:
    """Implements the Extended Euclidean algorithm given integers a and b, returning, in order:
    - the gcd(a,b)
    - integer x
    - integer y
    Such that a*x + b*y = gcd(a,b)"""
    old_r, r = a, b
    old_s, s = 1, 0
    old_t, t = 0, 1

    while r != 0:
        quotient = old_r // r
        old_r, r = r, old_r - quotient*r
        old_s, s = s, old_s - quotient*s
        old_t, t = t, old_t - quotient*t

    return old_r, old_s, old_t


def str_to_int(M_str: str) -> int:
    """Encodes an ascii string as an integer"""
    M_bytes = M_str.encode('ascii') # encode the string as ascii bytes
    return int.from_bytes(M_bytes, byteorder='big') # return bytes as integer

def int_to_str(M: int) -> str:
    """Decodes an integer back to an ascii string of up to 256 characters"""
    M_bytes = M.to_bytes(length = 256, byteorder = 'big') # convert int to 256 bytes
    M_bytes = M_bytes.lstrip(bytes(1)) # remove the leading all-zero bytes
    return M_bytes.decode('ascii') # return as string


def evaluate_forge_signature1(forge_signature1: Callable):
    """We will randomly generate p and q (1024 bits) when evaluating the assignments. This is just an example."""
    n = 16598701394611785782312147016840389375546737048793085539361918913963668450693179248037747833025356304595072967808905503284838077241813499787809296364694812054953507570528040597055782533819498527962374362909711899554172601808502122666971546792412855028171610439318926151957095666943637405434392563411252604206738639395424154245251387704489299981363377710321881888738654567510902486324895014790582684969555487289126136465484986984006470187350626550602848627068623136754636547824943300101716319142469498939039420085862128412511244577077284300737072537392992393022356813961463161168171906801645150260532973056078923483407
    e = 65537

    fails = 0
    for _ in range(100):
        M, T = forge_signature1(e, n)
        if mod_pow(T, e, n) != M:
            fails += 1
    print(f'forge_signature1 failure rate: {fails}% (this should be 0%)')


def evaluate_forge_signature2(forge_signature2: Callable):
    """We will randomly generate p and q (1024 bits) when evaluating the assignments. This is just an example."""
    n = 10544601499131813956729481057915493263462352303088103887239869856293080239053380144924609490061314087413332449867317900867176168039475942809406784907441519703532412291235007432907962427076730096930200221885841260612572241742930135541288930768283833543288361952845812733920959712967781435246065142518495843097634568506478605570393632939401816999882904425455751087506816892173390397236527985918769704691533902001390866574128034043464226252461479452089309431209464719867794721562247633299588958328100515640101035326857040426255378640430128349575678207778705296345544728157251152518653493121161438842844459269467136009109
    e = 65537
    M1=123456
    T1=5222213142217344937796464989207299431361381882399976480803210664219029821229089446945077044201921516308761751067505824251203274439998775280232226962549825794501955117308104472608663588953352872177306828278455234521151613815176552512027257871523728160629934593070153385029376980534185349954435218742228538723584202828010552795565301910198047616533468774823933676239544484862455727348404367991553968804641742552914741748132294763274533926957039813320536265277120209297154501586872759647818789894221995363256832029175120192774605096037887571411130799108054175036715997420077966701833722938027132938795674538150640820133
    M2=1000001
    T2=8982203844677098227453263087092068013532201807523503087099159685107972981120920891825274150239398305998083571464387103463582828505632203582395845898147423108746509892946432391283306230726294400864511976007702276830832617357734893984634759898408362469777562144768406974386402022210913635839114515466809687335815702349183559925604779780584160125438548658443006172418759302248565426571284720463008183836539619314671612563784380742883976880111641698487514161148546097178804139917011222945604159675201136297144619140153354206838369635634265995882239126284922785308425383596828997912025419676456303178839614564846753893789
    M3 = (M1 * M2) % n
    T3 = forge_signature2(M1, T1, M2, T2, e, n)
    print(T3)
    if mod_pow(T3, e, n) == M3:
        print("forge_signature2 passed")
    else:
        print("forge_signature2 failed!")



class Alice():

    def __init__(self):
        self.n = 13644727120269477007833088483489462256843209703623149953054248689496595446302872781788376774598531724710761370102377762081885006626981171448708491273802621205697246609270699097076385893980623245049401363799486242888363230131314911495867589087632261539521730346504216499043795284169720448311814078644011684999960698956657542650841685119886710653073501175365291599864628410481041861021799071203132211902803618072865773761064037354662861841228380958677853164467882194331335525906363091030014540450416582272556206008210163459996268052575930599302221585418096965921634268785155565770627270044352857331842668693994000634939
        self.d = 4233723331716126996266015446415890489233664484538150270768545205012638179968093107979715911797322773730767848101558688861790005794584160419449885866804649315926171625181495432184083909152020594291462482763363485498800163033405385130055807011260845604867088615532649381388461130408643442886014606851488130589887346692184690321906927844601738272472607574765571474747944992811202648858610576929883929471396504882802615130486167178306296510204984291947222869483379022576735018898164067185910205393809156178647657535528926824356063866160624843336901833629169246546710665636045862857550779685036368310911618820435878351473
        self.e = 65537

    def get_public_key(self):
        return self.e, self.n
    
    def sign(self, M: int):
        try:
            M_str = int_to_str(M)
        except UnicodeDecodeError:
            # M is not an ascii string, we can try to sign
            return mod_pow(M, self.d, self.n)
        else:
            if 'Eve' in M_str:
                raise ValueError("I cannot sign any message with the word 'Eve'")
            else:
                return mod_pow(M, self.d, self.n)


    def check_q24_correctness(self, M: int, T: int):
        if int_to_str(M) != "Transfer all of Alice's money to Eve":
            print("This is not the message you're supposed to get signed...")
            print(f"'{int_to_str(M)}'")
            return
        elif mod_pow(M, self.d, self.n) != T:
            print("The signature is not valid")
            return
        else:
            print("You've successfully forged the signature!")

    
def my_hash(input: bytes) -> bytes:
    return SHA256.new(data=input).digest()[:3]


class AliceAndBob():

    def __init__(self):
        self.K = random.randbytes(AES.block_size)

    def send_message(self, M: bytes):
        IV = random.randbytes(AES.block_size)
        cipher = AES.new(self.K, AES.MODE_CBC, iv=IV)
        M_padded = pad(M, AES.block_size)
        digest = SHA256.new(data=M_padded).digest()
        ciphertext = cipher.encrypt(M_padded + digest) # '+' is concatenation with bytes objects
        return ciphertext, IV
    
    def receive_message(self, ciphertext: bytes, IV: bytes):
        cipher = AES.new(self.K, AES.MODE_CBC, iv=IV)
        decrypted = cipher.decrypt(ciphertext)
        M_padded, digest = decrypted[:-32], decrypted[-32:]
        if SHA256.new(data=M_padded).digest() != digest:
            print("The received digest doesn't match the hash of the message!")
        else:
            print(f"Message accepted: '{unpad(M_padded, AES.block_size).decode('ascii')}'")

    def send_message_from_eve(self, M_eve: bytes):
        M = b"Eve said this, do not trust her: '" + M_eve + b"'"
        return self.send_message(M)

